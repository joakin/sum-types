{"version":3,"file":"index.umd.js","sources":["../src/type.js","../src/maybe.js","../src/result.js"],"sourcesContent":["function invalidCases(needed, provided) {\n  if (provided.length !== needed.length) return true;\n  for (let i in provided) if (provided[i] !== needed[i]) return true;\n  return false;\n}\n\nconst defaultProto = {\n  match(branches) {\n    const providedCases = Object.keys(branches);\n    if (invalidCases(providedCases.sort(), this.__cases__))\n      throw new Error(\n        `You need to provide cases for all of: ${this.__cases__.join(\n          \", \"\n        )}, but instead provided ${providedCases.join(\", \")}`\n      );\n    return branches[this.__name](...this.value);\n  },\n  toString() {\n    return (\n      this.__name +\n      (this.__fields ? `(${this.value.map(v => v.toString()).join(\", \")})` : \"\")\n    );\n  }\n};\n\nconst defaultStatics = {\n  match(cases) {\n    return instance => instance.match(cases);\n  }\n};\n\nexport const _ = {};\n\nexport function Type(cases, proto, statics) {\n  function Type(name, fields, values) {\n    this.__name = name;\n    this.__fields = fields.length;\n    if (values.length !== this.__fields)\n      throw new Error(\n        `Not enough fields provided for ${name}, was expecting ${\n          this.__fields\n        } value${this.__fields !== 1 ? \"s\" : \"\"} but received: ${values.join(\n          \", \"\n        )}`\n      );\n    values.forEach((value, i) => {\n      if (value == null)\n        throw new Error(`Argument ${i} was provided a null value: ${value}`);\n    });\n    this.value = values;\n  }\n  Object.assign(Type.prototype, proto, defaultProto);\n  const casesKeys = Object.keys(cases).sort();\n  Type.prototype.__cases__ = casesKeys;\n  Object.assign(Type, statics, defaultStatics);\n  casesKeys.forEach(c => {\n    Type[c] = (...args) => new Type(c, cases[c], args);\n  });\n  return Type;\n}\n","import { Type, _ } from \"./type\";\n\nconst Maybe = Type(\n  {\n    Just: [_],\n    Nothing: []\n  },\n  {\n    withDefault(x) {\n      return this.match({\n        Just: value => value,\n        Nothing: _ => x\n      });\n    },\n    map(fn) {\n      return this.match({\n        Just: value => Maybe.Just(fn(value)),\n        Nothing: _ => this\n      });\n    },\n    andThen(fn) {\n      return this.match({\n        Just: value => fn(value),\n        Nothing: _ => this\n      });\n    },\n    unwrap() {\n      return this.match({\n        Just: value => value,\n        Nothing: _ => null\n      });\n    }\n  },\n  {\n    from(x) {\n      return x != null ? Maybe.Just(x) : Maybe.Nothing();\n    },\n    map(fn, ...maybes) {\n      const values = [];\n      for (let i in maybes) {\n        const value = maybes[i].unwrap();\n        if (value == null) return Maybe.Nothing();\n        else values.push(value);\n      }\n      return Maybe.Just(fn(...values));\n    }\n  }\n);\n\nexport default Maybe;\n","import { Type, _ } from \"./type\";\nimport Maybe from \"./maybe\";\n\nconst Result = Type(\n  {\n    Ok: [_],\n    Err: [_]\n  },\n  {\n    withDefault(x) {\n      return this.match({\n        Ok: value => value,\n        Err: _ => x\n      });\n    },\n    map(fn) {\n      return this.match({\n        Ok: value => Result.Ok(fn(value)),\n        Err: _ => this\n      });\n    },\n    mapError(fn) {\n      return this.match({\n        Ok: _ => this,\n        Err: err => Result.Err(fn(err))\n      });\n    },\n    andThen(fn) {\n      return this.match({\n        Ok: value => fn(value),\n        Err: _ => this\n      });\n    },\n    toMaybe() {\n      return this.match({\n        Ok: value => Maybe.Just(value),\n        Err: _ => Maybe.Nothing()\n      });\n    },\n    unwrap() {\n      return this.match({\n        Ok: value => value,\n        Err: error => {\n          throw error;\n        }\n      });\n    }\n  },\n  {\n    try(fn) {\n      try {\n        return Result.Ok(fn());\n      } catch (e) {\n        return Result.Err(e);\n      }\n    },\n    fromMaybe(err, maybe) {\n      return maybe.match({\n        Just: value => Result.Ok(value),\n        Nothing: _ => Result.Err(err)\n      });\n    },\n    fromPromise(promise) {\n      return promise\n        .then(value => Result.Ok(value))\n        .catch(err => Result.Err(err));\n    },\n    map(fn, ...results) {\n      const values = [];\n      for (let i in results) {\n        try {\n          values.push(results[i].unwrap());\n        } catch (e) {\n          return Result.Err(e);\n        }\n      }\n      return Result.Ok(fn(...values));\n    }\n  }\n);\n\nexport default Result;\n"],"names":["const","defaultProto","match","branches","providedCases","Object","keys","needed","provided","length","let","i","invalidCases","sort","this","__cases__","Error","join","__name","value","toString","__fields","map","v","defaultStatics","cases","instance","_","Type","proto","statics","name","fields","values","forEach","assign","prototype","casesKeys","c","args","Maybe","Just","Nothing","withDefault","x","fn","andThen","unwrap","from","maybes","push","Result","Ok","Err","mapError","err","toMaybe","error","try","e","fromMaybe","maybe","fromPromise","promise","then","catch","results"],"mappings":"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"}